using System;
using System.Collections.Generic;
using System.Linq;

// 문제: 백준 2178 - 미로 탐색
// N×M 크기의 배열로 표현되는 미로가 있다.
// 미로에서 1은 이동할 수 있는 칸을 나타내고, 0은 이동할 수 없는 칸을 나타낸다.
// 이러한 미로가 주어졌을 때, (1, 1)에서 출발하여 (N, M)의 위치로 이동할 때 지나야 하는 최소의 칸 수를 구하는 프로그램을 작성하시오.
// 한 칸에서 다른 칸으로 이동할 때, 서로 인접한 칸으로만 이동할 수 있다.
// 위의 예에서는 15칸을 지나야 (N, M)의 위치로 이동할 수 있다. 칸을 셀 때에는 시작 위치와 도착 위치도 포함한다.

// 입력
// 첫째 줄에 두 정수 N, M(2 ≤ N, M ≤ 100)이 주어진다. 다음 N개의 줄에는 M개의 정수로 미로가 주어진다. 각각의 수들은 붙어서 입력으로 주어진다.

// 출력
// 첫째 줄에 지나야 하는 최소의 칸 수를 출력한다. 항상 도착위치로 이동할 수 있는 경우만 입력으로 주어진다.

// 예제 입력:
// 4 6
// 101111
// 101010
// 101011
// 111011

// 예제 출력:
// 15

// 문제 해결을 위한 질문지:
// 1. 이 문제를 어떤 알고리즘으로 해결할 수 있을까요? 인접한 다른 칸을 이동할수 있다 와 최소 칸 수를 구하는데 힌트가 있을 것 같은데.. 모르겠네요 
// 2. 시간 복잡도는 어떻게 될까요? 모르겠습니다.

// 피드백 및 추가 질문:
// 1번 질문에 대한 피드백:
// - "인접한 다른 칸을 이동할 수 있다"와 "최소 칸 수를 구하는데 힌트가 있을 것 같은데"라는 생각은 매우 좋은 접근입니다!
// - 문제의 핵심 키워드를 다시 한번 살펴보면:
//   1. "인접한 칸으로만 이동할 수 있다" - 이는 현재 위치에서 상하좌우로만 이동할 수 있다는 의미입니다.
//   2. "최소의 칸 수를 구하는 프로그램" - 최단 경로를 찾아야 한다는 의미입니다.
// - 이러한 특징을 가진 문제를 해결하기 위해서는:
//   - 모든 가능한 경로를 탐색하면서
//   - 각 위치까지의 최단 거리를 기록하고
//   - 목적지에 도달할 때까지 계속해서 탐색을 진행해야 합니다.

// 추가 질문:
// 1. 위의 특징들을 바탕으로, 이 문제를 해결하기 위한 알고리즘을 생각해보세요.
//    - 모든 가능한 경로를 탐색해야 합니다.
//    - 각 위치까지의 최단 거리를 기록해야 합니다.
//    - 목적지에 도달할 때까지 계속해서 탐색을 진행해야 합니다.
//    이러한 특징을 가진 알고리즘은 무엇일까요? DFS는 전체가 아니기 때문에 BFS로 생각이 듭니다. 

// 2. 시간 복잡도 계산을 위한 힌트:
//    - 미로의 크기가 N×M입니다.
//    - 각 칸을 최대 한 번씩만 방문하게 됩니다.
//    - 각 칸을 방문할 때마다 상하좌우 4방향을 확인합니다.
//    이를 바탕으로 시간 복잡도를 계산해보세요. O(N*M)

// 피드백 및 추가 질문:
// 1번 답변에 대한 피드백:
// - BFS를 선택하신 것은 정확한 판단입니다!
// - BFS가 이 문제에 적합한 이유를 더 자세히 설명해보세요:
//   1. BFS는 왜 최단 경로를 찾는데 적합할까요? 이진트리를 이용해서 시작과 도착지에 대한 값을 가져와 비교하여 최단거리를 찾을 수 있기 때문입니다. 
//   2. DFS와 BFS의 차이점은 무엇일까요? DFS는 전체가 아닌 하나의 노드에 대한 최소가 아닐까요?
//   3. 이 문제에서 BFS를 사용하면 어떤 순서로 칸들을 방문하게 될까요? 시작점을 기준으로 왼쪽으로 오른쪽 탐색 합니다. 

// 2번 답변에 대한 피드백:
// - O(N*M)이라는 시간 복잡도는 정확합니다!
// - 하지만 더 자세한 설명이 필요합니다:
//   1. 각 칸을 한 번씩만 방문한다는 것이 시간 복잡도에 어떤 영향을 미치나요? 값이 아무리 커도 한번만 방문하기 때문에 차수가 증가하지 않습니다. 
//   2. 각 칸에서 상하좌우 4방향을 확인하는 것은 시간 복잡도에 어떤 영향을 미치나요? 하나의 노드를 방문할때마다 4방향을 체크 해야하기 때문에 증가합니다. 
//   3. 최종 시간 복잡도가 O(N*M)이 되는 과정을 단계별로 설명해보세요. 미로의 크기 n과 m의 갯수만큼 확인하니 빅오 표기법으로 O(N*M)

// 최종 피드백 및 추가 질문:
// 1번 답변에 대한 피드백:
// - BFS에 대한 이해가 있으시지만, 몇 가지 중요한 개념을 더 명확히 할 필요가 있습니다:
//   1. BFS는 이진트리가 아닌 그래프에서도 사용할 수 있습니다. 이 문제는 2차원 배열(그래프)에서의 BFS입니다.
//   2. BFS가 최단 경로를 찾는데 적합한 이유는 "레벨 단위 탐색" 때문입니다. 같은 레벨의 모든 노드를 먼저 방문한 후 다음 레벨로 넘어가기 때문입니다.
//   3. DFS와 BFS의 주요 차이점은:
//      - DFS: 깊이 우선 탐색으로, 한 경로를 끝까지 탐색한 후 돌아와서 다른 경로를 탐색합니다.
//      - BFS: 너비 우선 탐색으로, 현재 위치에서 갈 수 있는 모든 경로를 동시에 탐색합니다.
//   4. BFS의 방문 순서는 "시작점을 기준으로 왼쪽으로 오른쪽 탐색"이 아니라, "시작점에서 거리가 같은 모든 칸을 먼저 방문"하는 방식입니다.

// 2번 답변에 대한 피드백:
// - 시간 복잡도에 대한 기본적인 이해는 있으시지만, 더 정확한 설명이 필요합니다:
//   1. 각 칸을 한 번씩만 방문한다는 것은 O(N*M)의 기본이 됩니다.
//   2. 각 칸에서 4방향을 확인하는 것은 상수 시간 O(1)이므로, 최종 시간 복잡도에 영향을 주지 않습니다.
//   3. 따라서 최종 시간 복잡도는 O(N*M)이 됩니다.

// 추가 질문:
// 1. BFS를 사용할 때 필요한 자료구조는 무엇일까요? 그리고 그 이유는 무엇일까요? queue이며, 노드를 타고 들어간 후 빠져나올때 바로 이전의 노드로 나와야해서 
// 2. 이 문제에서 각 칸까지의 최단 거리를 어떻게 기록할 수 있을까요? 방문할때마다 값을 비교하여 저장
// 3. BFS를 구현할 때 주의해야 할 점은 무엇일까요? 재방문하지 않아야함

// 최종 피드백 및 추가 질문:
// 1번 답변에 대한 피드백:
// - Queue를 선택하신 것은 정확합니다! 하지만 그 이유를 더 정확히 설명해드리겠습니다:
//   1. Queue는 FIFO(First In First Out) 구조를 가집니다.
//   2. BFS에서 Queue를 사용하는 이유는:
//      - 같은 레벨의 노드들을 먼저 처리해야 하기 때문입니다.
//      - 먼저 들어온 노드를 먼저 처리해야 최단 경로를 보장할 수 있습니다.
//   3. "이전의 노드로 나와야해서"라는 설명은 정확하지 않습니다. BFS는 이전 노드로 돌아가지 않고, 다음 레벨의 노드들을 순차적으로 처리합니다.

// 2번 답변에 대한 피드백:
// - "방문할때마다 값을 비교하여 저장"이라는 접근은 좋지만, 더 구체적인 방법이 필요합니다:
//   1. 2차원 배열을 사용하여 각 칸까지의 최단 거리를 기록할 수 있습니다.
//   2. BFS의 특성상, 각 칸에 처음 도달했을 때의 거리가 최단 거리가 됩니다.
//   3. 따라서 별도의 비교 없이, 방문하지 않은 칸에 도달했을 때 거리를 기록하면 됩니다.

// 3번 답변에 대한 피드백:
// - "재방문하지 않아야함"이라는 답변은 정확합니다! 하지만 더 구체적인 주의사항이 있습니다:
//   1. 방문 여부를 체크하는 배열이 필요합니다.
//   2. 미로의 범위를 벗어나지 않도록 체크해야 합니다.
//   3. 이동할 수 없는 칸(0)은 방문하지 않아야 합니다.

// 추가 질문:
// 1. 이 문제에서 상하좌우 이동을 어떻게 구현할 수 있을까요? int[]형으로 x,y를 만들어 상하좌우 이동 좌표를 만들어서 구현
// 2. 시작점(0,0)에서 도착점(N-1, M-1)까지의 최단 거리를 어떻게 구할 수 있을까요? 이동할때마다 거리를 저장하며 비교?
// 3. 실제 코드를 작성할 때, 어떤 부분에서 실수하기 쉬울까요? 모르겠음

// 최종 피드백 및 마지막 질문:
// 1번 답변에 대한 피드백:
// - 상하좌우 이동을 int[] 배열로 구현하는 것은 좋은 접근입니다!
// - 하지만 더 구체적인 방법이 필요합니다:
//   1. dx[] = {-1, 1, 0, 0} // 상하좌우 x좌표 변화
//   2. dy[] = {0, 0, -1, 1} // 상하좌우 y좌표 변화
//   3. 이렇게 하면 for문으로 4방향을 쉽게 처리할 수 있습니다.

// 2번 답변에 대한 피드백:
// - "이동할때마다 거리를 저장하며 비교"라는 접근은 좋지만, BFS의 특성을 활용하면 더 효율적입니다:
//   1. BFS는 레벨 단위로 탐색하므로, 각 칸에 처음 도달했을 때의 거리가 최단 거리입니다.
//   2. 따라서 별도의 비교 없이, 방문하지 않은 칸에 도달했을 때 거리를 기록하면 됩니다.
//   3. 거리는 이전 칸의 거리 + 1로 계산할 수 있습니다.

// 3번 답변에 대한 피드백:
// - 실수하기 쉬운 부분들을 알려드리겠습니다:
//   1. 배열 인덱스: C#은 0-based indexing을 사용하므로, (1,1)에서 (N,M)으로 이동할 때는 (0,0)에서 (N-1,M-1)로 변환해야 합니다.
//   2. 방문 체크: 방문 체크를 Queue에 넣기 전에 해야 합니다.
//   3. 거리 계산: 시작점의 거리는 1로 초기화해야 합니다.

// 마지막 질문:
// 1. 이제 실제 코드를 작성해볼까요? 아니면 더 궁금한 점이 있으신가요?

namespace ExampleProblems
{
    class Q_1
    {
        static void Main(string[] args)
        {
            
        }
    }
} 